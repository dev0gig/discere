<!DOCTYPE html>
<html lang="de" class="dark">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Discere - Lernkarten</title>
<link rel="icon" type="image/svg+xml" href="discere.svg">
    <link rel="manifest" href="manifest.json">

    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js" defer></script>
     <link rel="preconnect" href="https://fonts.googleapis.com">
     <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet"
        href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />

    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    screens: {
                        '2xl': '1900px',
                    },
                    fontFamily: {
                        sans: ['Ubuntu', 'sans-serif'],
                    },
                    colors: {
                        'neutral-bg': '#121212',
                        'neutral-surface': '#1e1e1e',
                        'neutral-border': '#444444',
                        'neutral-primary': 'var(--accent-color)',
                        'neutral-secondary': '#03dac6',
                        'neutral-text': '#e0e0e0',
                        'neutral-dim': '#a0a0a0',
                    },
                    boxShadow: {
                        'primary': '0 0 12px rgba(0, 0, 0, 0.8)',
                    }
                }
            }
        }
    </script>

    <style>
       :root {
           --accent-color: #E0E0E0;
       }
       body{
           overflow: hidden;
           background-color: #121212;
        }
       .card {
            transform-style: preserve-3d;
            transition: transform 0.6s;
        }

        .card-face {
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
        }

        .card-back {
            transform: rotateY(180deg);
        }

        .is-flipped {
            transform: rotateY(180deg);
        }

        .custom-scrollbar::-webkit-scrollbar {
            width: 8px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
            background: transparent;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background-color: #444444; /* neutral-border */
            border-radius: 4px;
            border: 2px solid #1e1e1e; /* neutral-surface */
        }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background-color: var(--accent-color);
        }
        .custom-scrollbar {
            scrollbar-width: thin;
            scrollbar-color: #444444 transparent; /* thumb track */
            -webkit-overflow-scrolling: touch;
        }
         .glass {
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 1rem;
        }
        .bottom-bar-glass {
             background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }
    </style>
</head>

<body class="font-sans text-neutral-text h-screen bg-cover bg-center bg-fixed" x-data="flashcardTrainer()">

    <div class="container mx-auto p-4 h-full">

        <div class="flex flex-col 2xl:flex-row 2xl:gap-8 w-full h-full">

            <aside class="fixed inset-0 z-40 transform transition-transform duration-300 ease-in-out 2xl:relative 2xl:inset-auto 2xl:w-1/3 2xl:transform-none 2xl:z-auto glass" :class="{'translate-y-0': cardListVisible, 'translate-y-full': !cardListVisible}">
                <div class="p-4 h-full flex flex-col relative">
                    <div class="flex-shrink-0">
                        <div class="flex justify-between items-center mb-4">
                            <h2 class="font-bold text-2xl text-neutral-primary">Kartenliste</h2>
                            <button @click="cardListVisible = false" class="2xl:hidden p-1 rounded-md hover:bg-neutral-border">
                                <span class="material-symbols-outlined">close</span>
                            </button>
                        </div>
    
                        <div class="flex gap-2 mb-4">
                            <button @click="showAddCardModal = true" title="Neue Karte" class="flex-grow p-2 rounded-md bg-neutral-primary text-neutral-bg font-bold hover:shadow-primary transition-shadow flex items-center justify-center">
                                <span class="material-symbols-outlined">add_circle</span>
                                <span class="ml-2">Neue Karte</span>
                            </button>
                            <button @click="showHelpModal = true" title="Anleitung" class="p-2 rounded-md bg-blue-600 text-white hover:bg-blue-500 transition-colors flex items-center justify-center">
                               <span class="material-symbols-outlined">help</span>
                            </button>
                            <button @click="exportCards()" title="Backup erstellen" class="p-2 rounded-md glass border-none hover:bg-neutral-primary hover:text-neutral-bg transition-colors flex items-center justify-center">
                                <span class="material-symbols-outlined">save</span>
                            </button>
                            <button @click="$refs.importInput.click()" title="Backup einspielen" class="p-2 rounded-md glass border-none hover:bg-neutral-primary hover:text-neutral-bg transition-colors flex items-center justify-center">
                                <span class="material-symbols-outlined">folder_open</span>
                            </button>
                            <input type="file" x-ref="importInput" @change="importCards($event)" class="hidden" accept=".json">
                            <button @click="showSettingsModal = true" title="Einstellungen" class="p-2 rounded-md bg-neutral-surface hover:bg-neutral-border transition-colors flex items-center justify-center">
                                <span class="material-symbols-outlined">settings</span>
                            </button>
                            <button x-show="selectedCards.length > 0" x-transition @click="deleteSelectedCards()" title="Ausgewählte löschen" class="p-2 rounded-md bg-red-600 text-white font-bold hover:bg-red-500 transition-colors flex items-center justify-center">
                                <span class="material-symbols-outlined">delete</span>
                            </button>
                        </div>
                    </div>

                    <div @click.away="selectedCards = []; lastSelectedCardId = null" class="flex-grow min-h-0">
                        <div x-ref="cardListContainer" class="h-full overflow-y-auto pr-2 custom-scrollbar">
                            <template x-for="card in sortedCards" :key="card.id">
                                <div class="flex justify-between items-center group hover:bg-neutral-surface rounded-md">
                                    <div @click="handleCardClick(card, $event)"
                                         @touchstart="handleCardTouchStart(card, $event)"
                                         @touchend="handleCardTouchEnd(card, $event)"
                                         @touchmove="handleCardTouchMove()"
                                         :class="selectedCards.includes(card.id) ? 'bg-neutral-primary text-neutral-bg' : ''"
                                         class="flex-grow px-3 py-2 cursor-pointer rounded-md text-sm grid grid-cols-2 items-center transition-colors duration-200">
                                       <span class="truncate" x-text="card.front"></span>
                                       <span class="text-neutral-dim text-right truncate" :class="{'text-neutral-bg': selectedCards.includes(card.id)}" x-text="card.back"></span>
                                    </div>
                                    <div class="flex items-center opacity-0 group-hover:opacity-100 transition-opacity">
                                        <button @click.stop="editCard(card)" title="Bearbeiten" class="p-1 text-neutral-dim hover:text-neutral-primary">
                                            <span class="material-symbols-outlined text-base">edit</span>
                                        </button>
                                        <button @click.stop="deleteCard(card)" title="Löschen" class="p-1 text-neutral-dim hover:text-red-500">
                                            <span class="material-symbols-outlined text-base">delete</span>
                                        </button>
                                    </div>
                                </div>
                            </template>
                        </div>
                    </div>
                </div>
            </aside>

            <main class="w-full 2xl:w-2/3 flex-shrink-0 flex flex-col p-2 h-full pb-24 2xl:pb-2">
                <div class="flex-shrink-0">


                </div>

                <div class="flex-grow flex flex-col gap-4 min-h-0">
                    <!-- Drawing Canvas -->
                    <div class="flex-1 w-full min-h-0 relative">
                        <canvas x-ref="drawingCanvas" class="w-full h-full glass cursor-crosshair"></canvas>
                        <button @click="clearCanvas()" title="Feld leeren" class="absolute bottom-2 right-2 p-2 rounded-full text-red-500 hover:text-red-400 transition-colors flex items-center justify-center">
                            <span class="material-symbols-outlined">delete</span>
                        </button>
                    </div>

                    <!-- Card -->
                    <div @touchstart="handleTouchStart($event)" @touchend="handleTouchEnd($event)" style="perspective: 1000px;" class="w-full h-56 flex-shrink-0 min-h-0 2xl:flex-1 relative">
                        <!-- Nav Arrows -->
                        <button @click="previousCard()" class="absolute left-2 top-1/2 -translate-y-1/2 z-10 p-2 rounded-full text-neutral-dim hover:text-neutral-primary transition-colors">
                            <span class="material-symbols-outlined">chevron_left</span>
                        </button>
                        <button @click="nextCard()" class="absolute right-2 top-1/2 -translate-y-1/2 z-10 p-2 rounded-full text-neutral-dim hover:text-neutral-primary transition-colors">
                            <span class="material-symbols-outlined">chevron_right</span>
                        </button>

                        <div class="relative w-full h-full card" :class="{ 'is-flipped': flipped }">
                            <div @click="flipped = !flipped"
                                class="absolute w-full h-full card-face glass flex items-center justify-center cursor-pointer shadow-primary p-4 overflow-hidden">
                                <p class="text-3xl 2xl:text-4xl font-bold text-neutral-text text-center"
                                    x-text="sidesSwapped ? currentCard.back : currentCard.front" x-ref="cardFrontText"></p>
                            </div>
                            <div @click="flipped = !flipped"
                                class="absolute w-full h-full card-face card-back glass flex flex-col items-center justify-center cursor-pointer shadow-primary p-4 overflow-hidden">
                                <p class="text-3xl 2xl:text-4xl font-bold text-neutral-primary text-center"
                                    x-text="sidesSwapped ? currentCard.front : currentCard.back" x-ref="cardBackText"></p>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="flex-shrink-0 mt-4">
                    <div class="mb-4 w-full relative">
                        <input type="text" x-model="searchTerm" @input.debounce.300ms="updateSearchResults()"
                            placeholder="Karte suchen..."
                            class="w-full px-4 py-2 pr-10 glass border-none rounded-md focus:outline-none focus:ring-2 focus:ring-neutral-primary text-neutral-text placeholder-neutral-dim">
                        <button @click="resetSearch()" x-show="searchTerm.trim() !== ''" x-transition class="absolute top-1/2 right-3 transform -translate-y-1/2 text-neutral-dim hover:text-neutral-primary z-10 cursor-pointer">
                            <span class="material-symbols-outlined">close</span>
                        </button>

                        <div x-show="searchResults.length > 0" x-transition
                            class="absolute z-10 w-full bottom-full mb-1 glass border-none rounded-md max-h-60 overflow-y-auto shadow-lg custom-scrollbar">
                            <template x-for="card in searchResults" :key="card.id">
                                <div @click="selectCard(card)"
                                    class="px-4 py-2 cursor-pointer hover:bg-neutral-primary/80 hover:text-neutral-bg flex justify-between items-center">
                                    <span x-text="card.front"></span>
                                    <span class="text-neutral-dim text-right" x-text="card.back"></span>
                                </div>
                            </template>
                        </div>
                    </div>
                </div>
            </main>


           <div x-show="showAddCardModal" x-transition:enter="transition ease-out duration-300" x-transition:enter-start="opacity-0" x-transition:enter-end="opacity-100" x-transition:leave="transition ease-in duration-200" x-transition:leave-start="opacity-100" x-transition:leave-end="opacity-0" class="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4" style="display: none;">
               <div @click.away="closeModal()" class="glass shadow-primary p-6 w-full max-w-md">
                   <h3 class="font-bold text-2xl text-neutral-primary mb-4" x-text="editingCard ? 'Karte bearbeiten' : 'Neue Karte hinzufügen'"></h3>
                   <form @submit.prevent="saveCard()">
                       <div class="space-y-4">
                           <div>
                               <label for="newFront" class="block text-neutral-dim mb-1">Vorderseite</label>
                               <input type="text" id="newFront" x-model="newCard.front" required class="w-full px-3 py-2 glass border-none rounded-md focus:outline-none focus:ring-2 focus:ring-neutral-primary text-neutral-text placeholder-neutral-dim">
                           </div>
                           <div>
                               <label for="newBack" class="block text-neutral-dim mb-1">Rückseite</label>
                               <input type="text" id="newBack" x-model="newCard.back" required class="w-full px-3 py-2 glass border-none rounded-md focus:outline-none focus:ring-2 focus:ring-neutral-primary text-neutral-text placeholder-neutral-dim">
                           </div>
                       </div>
                       <div class="flex justify-end gap-4 mt-6">
                           <button type="button" @click="closeModal()" class="px-4 py-2 rounded-md text-neutral-dim hover:text-neutral-primary">Abbrechen</button>
                           <button type="submit" class="px-4 py-2 rounded-md bg-neutral-primary text-neutral-bg font-bold hover:shadow-primary">Speichern</button>
                       </div>
                   </form>
               </div>
           </div>

           <!-- Settings Modal -->
           <div x-show="showSettingsModal" x-transition:enter="transition ease-out duration-300" x-transition:enter-start="opacity-0" x-transition:enter-end="opacity-100" x-transition:leave="transition ease-in duration-200" x-transition:leave-start="opacity-100" x-transition:leave-end="opacity-0" class="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4" style="display: none;">
               <div @click.away="showSettingsModal = false" class="glass shadow-primary p-6 w-full max-w-md">
                   <h3 class="font-bold text-2xl text-neutral-primary mb-6">Einstellungen</h3>
                   
                   <div class="space-y-6">
                       <div class="flex items-center justify-between">
                           <span class="text-neutral-text">Vorder- & Rückseite tauschen</span>
                           <button @click="swapSides()" :class="sidesSwapped ? 'bg-neutral-primary' : 'bg-neutral-surface'" class="relative inline-flex h-6 w-11 items-center rounded-full transition-colors">
                               <span :class="sidesSwapped ? 'translate-x-6' : 'translate-x-1'" class="inline-block h-4 w-4 transform rounded-full bg-white transition-transform"></span>
                           </button>
                       </div>

                       <div>
                           <label class="block text-neutral-dim mb-2">Kartenreihenfolge</label>
                           <div class="flex gap-2">
                               <button @click="setCardOrder('random')" :class="{ 'bg-neutral-primary text-neutral-bg': cardOrder === 'random', 'bg-neutral-surface': cardOrder !== 'random' }" class="flex-1 py-2 px-4 rounded-md transition-colors">
                                   Zufällig
                               </button>
                               <button @click="setCardOrder('sequential')" :class="{ 'bg-neutral-primary text-neutral-bg': cardOrder === 'sequential', 'bg-neutral-surface': cardOrder !== 'sequential' }" class="flex-1 py-2 px-4 rounded-md transition-colors">
                                   In Reihe
                               </button>
                           </div>
                       </div>

                       <div>
                           <label class="block text-neutral-dim mb-2">Hintergrundbild</label>
                           <div class="flex gap-2">
                               <input type="text" x-model="newBgUrl" placeholder="Bild-URL einfügen..." class="flex-grow px-3 py-2 glass border-none rounded-md focus:outline-none focus:ring-2 focus:ring-neutral-primary text-neutral-text placeholder-neutral-dim text-sm">
                               <button @click="applyBgUrl()" class="px-3 py-2 rounded-md bg-neutral-surface hover:bg-neutral-border transition-colors">OK</button>
                           </div>
                           <div class="mt-2 text-center">
                               <span class="text-neutral-dim text-sm">oder</span>
                           </div>
                           <div class="flex gap-2 mt-2">
                               <button @click="$refs.bgUpload.click()" class="flex-1 px-3 py-2 rounded-md bg-neutral-surface hover:bg-neutral-border transition-colors text-sm">
                                   Hochladen
                               </button>
                               <button @click="removeBackground()" class="flex-1 px-3 py-2 rounded-md bg-neutral-surface hover:bg-neutral-border transition-colors text-sm">
                                   Entfernen
                               </button>
                           </div>
                           <input type="file" x-ref="bgUpload" @change="handleBgUpload($event)" class="hidden" accept="image/*">
                       </div>

                       <div>
                           <label class="block text-neutral-dim mb-2">Gefahrenzone</label>
                           <button @click="deleteAllCards()" class="w-full px-3 py-2 rounded-md bg-red-600 text-white font-bold hover:bg-red-500 transition-colors text-sm">
                               Alle Karten löschen
                           </button>
                       </div>
                   </div>

                   <div class="flex justify-end mt-8">
                       <button @click="showSettingsModal = false" class="px-4 py-2 rounded-md bg-neutral-primary text-neutral-bg font-bold hover:shadow-primary">Fertig</button>
                   </div>
               </div>
           </div>

          <!-- Help Modal -->
          <div x-show="showHelpModal" x-transition:enter="transition ease-out duration-300" x-transition:enter-start="opacity-0" x-transition:enter-end="opacity-100" x-transition:leave="transition ease-in duration-200" x-transition:leave-start="opacity-100" x-transition:leave-end="opacity-0" class="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4" style="display: none;">
              <div @click.away="showHelpModal = false" class="glass shadow-primary p-6 w-full max-w-lg">
                  <h3 class="font-bold text-2xl text-neutral-primary mb-4">Anleitung</h3>
                  <div class="space-y-4 text-neutral-text custom-scrollbar pr-2" style="max-height: 70vh; overflow-y: auto;">
                      <p class="font-bold">Wie funktioniert die App?</p>
                      <p>Discere ist eine einfache Lernkarten-App. Du kannst Karten mit einer Vorder- und Rückseite erstellen und dich dann selbst abfragen.</p>
                      <ul class="list-disc list-inside space-y-2 pl-4">
                          <li><strong class="text-neutral-primary">Karte hinzufügen:</strong> Klicke auf das <span class="material-symbols-outlined !text-sm inline-block align-middle">add_circle</span> Symbol, um eine neue Karte zu erstellen.</li>
                          <li><strong class="text-neutral-primary">Karte umdrehen:</strong> Klicke auf die große Karte, um die Antwort zu sehen. Auf Mobilgeräten kannst du auch wischen.</li>
                          <li><strong class="text-neutral-primary">Nächste/Vorherige:</strong> Nutze die Pfeile links und rechts neben der Karte oder die Pfeiltasten auf deiner Tastatur.</li>
                          <li><strong class="text-neutral-primary">Zeichnen:</strong> Unter der Karte befindet sich ein Feld, auf dem du zur Übung schreiben oder zeichnen kannst.</li>
                          <li><strong class="text-neutral-primary">Kartenliste:</strong> Alle deine Karten sind links aufgelistet. Du kannst sie bearbeiten, löschen oder mehrere auswählen (mit Strg/Shift oder langem Drücken auf Mobilgeräten).</li>
                      </ul>

                      <p class="font-bold mt-6">JSON-Importformat</p>
                      <p>Du kannst Karten aus einer <code>.json</code>-Datei importieren. Die Datei muss ein Array von Objekten enthalten, wobei jedes Objekt eine "front" und eine "back" Eigenschaft haben muss.</p>
                      <p>Beispiel:</p>
                      <pre class="bg-neutral-surface p-3 rounded-md text-sm overflow-x-auto custom-scrollbar"><code>[
{
  "front": "Was ist die Hauptstadt von Deutschland?",
  "back": "Berlin"
},
{
  "front": "Wie hoch ist der Eiffelturm?",
  "back": "324 Meter"
}
]</code></pre>
                  </div>
                  <div class="flex justify-end mt-6">
                      <button @click="showHelpModal = false" class="px-4 py-2 rounded-md bg-neutral-primary text-neutral-bg font-bold hover:shadow-primary">Verstanden</button>
                  </div>
              </div>
          </div>
       </div>

           <!-- Import Confirm Modal -->
           <div x-show="showImportConfirmModal" x-transition:enter="transition ease-out duration-300" x-transition:enter-start="opacity-0" x-transition:enter-end="opacity-100" x-transition:leave="transition ease-in duration-200" x-transition:leave-start="opacity-100" x-transition:leave-end="opacity-0" class="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4" style="display: none;">
               <div @click.away="cancelImport()" class="glass shadow-primary p-6 w-full max-w-md">
                   <h3 class="font-bold text-2xl text-neutral-primary mb-4">Karten importieren</h3>
                   <p class="text-neutral-text mb-6">Es sind bereits Karten vorhanden. Wie möchten Sie mit den importierten Karten fortfahren?</p>
                   <div class="flex justify-end gap-4 mt-6">
                       <button @click="mergeImport()" class="px-4 py-2 rounded-md bg-neutral-surface hover:bg-neutral-border">Ergänzen</button>
                       <button @click="replaceImport()" class="px-4 py-2 rounded-md bg-neutral-primary text-neutral-bg font-bold hover:shadow-primary">Ersetzen</button>
                       <button @click="cancelImport()" class="px-4 py-2 rounded-md text-neutral-dim hover:text-neutral-primary">Abbrechen</button>
                   </div>
               </div>
           </div>
    
      <!-- Bottom Bar -->
        <div class="2xl:hidden fixed bottom-0 left-0 right-0 h-16 flex items-center justify-between px-4 z-30 bottom-bar-glass">
            <h1 class="font-bold text-2xl text-neutral-primary">Discere</h1>
            <button @click="cardListVisible = !cardListVisible" class="p-2">
                <span class="material-symbols-outlined text-3xl">menu</span>
            </button>
        </div>
    </div>
 
    <script>
        function flashcardTrainer() {
            return {
                // Data State
                // Data State
                allCards: [], // The full, sorted list of all cards
                
                // View/UI State
                cards: [], // The shuffled, currently active card set for training
                currentIndex: 0,
                currentCard: { id: 0, front: 'Lade...', back: '...' },
                flipped: false,
                searchTerm: '',
                searchResults: [],
                cardListVisible: false,
                showAddCardModal: false,
                newCard: { id: null, front: '', back: '' },
                editingCard: null,
                selectedCards: [],
                lastSelectedCardId: null,
                showSettingsModal: false,
                showImportConfirmModal: false,
                showHelpModal: false,
                cardsToImport: [],
                sidesSwapped: false,
                cardOrder: 'random', // 'random' or 'sequential'
                newBgUrl: '',
 
                // Touch / Selection State
                longPressTimer: null,
                isMarkingMode: false,

                // Canvas State
                drawing: false,
                canvasContext: null,
                touchStartX: 0,

                get sortedCards() {
                    return [...this.allCards].sort((a, b) => a.front.localeCompare(b.front));
                },

                init() {
                   const savedBg = localStorage.getItem('discere_background_image');
                   if (savedBg) {
                       document.body.style.backgroundImage = `url('${savedBg}')`;
                   } else {
                       document.body.style.backgroundImage = '';
                   }
                    this.loadCards();
                    this.initCanvas();
 
                     this.$watch('sidesSwapped', (value) => {
                        localStorage.setItem('discere_sides_swapped', value);
                       this.adjustFontSize();
                    });
                    this.$watch('cardOrder', (value) => {
                       localStorage.setItem('discere_card_order', value);
                       this.loadCards(); // Reload cards to apply new order
                    });
                    this.$watch('currentCard', () => this.adjustFontSize());
                    this.$watch('flipped', () => this.adjustFontSize());
                    this.$watch('selectedCards.length', (length) => {
                       this.isMarkingMode = length > 0;
                    });
                    let resizeTimeout;
                    window.addEventListener('resize', () => {
                        clearTimeout(resizeTimeout);
                        resizeTimeout = setTimeout(() => {
                            this.adjustFontSize();
                            
                            this.$nextTick(() => {
                                const canvas = this.$refs.drawingCanvas;
                                if (!canvas || !this.canvasContext) return;
                                canvas.width = canvas.offsetWidth;
                                canvas.height = canvas.offsetHeight;
                                // Re-apply styles as they can be reset
                                this.canvasContext.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent-color');
                                this.canvasContext.lineWidth = 3;
                                this.canvasContext.lineCap = 'round';
                                this.canvasContext.lineJoin = 'round';
                            });
                        }, 150);
                    });
                   window.addEventListener('keydown', (e) => {
                       if (this.showAddCardModal) return; // Do not interfere with typing in the modal
                       if (e.key === 'ArrowRight') {
                           this.nextCard();
                       } else if (e.key === 'ArrowLeft') {
                           this.previousCard();
                       } else if (e.key === ' ') {
                           e.preventDefault(); // Prevent scrolling
                           this.flipped = !this.flipped;
                       }
                   });
                },

                loadCards() {
                   // Load settings from localStorage
                   this.sidesSwapped = localStorage.getItem('discere_sides_swapped') === 'true';
                   this.cardOrder = localStorage.getItem('discere_card_order') || 'random';

                    const savedCards = localStorage.getItem('discere_cards');
                    if (savedCards) {
                        try {
                            const parsedCards = JSON.parse(savedCards);
                            if (Array.isArray(parsedCards)) {
                                this.allCards = parsedCards.map(c => ({...c, id: c.id || Date.now() + Math.random()}));
                            }
                        } catch (e) {
                            console.error("Fehler beim Laden der Karten.", e);
                            this.allCards = [];
                        }
                    } else {
                         this.allCards = [];
                    }
                    
                    if (this.cardOrder === 'sequential') {
                        this.cards = this.sortedCards;
                    } else {
                        this.cards = [...this.allCards];
                        this.shuffleCards();
                    }

                    this.currentIndex = 0;
                    if (this.cards.length > 0) {
                        this.currentCard = this.cards[0];
                    } else {
                        this.currentCard = { id: 0, front: 'Keine Karten', back: 'Füge eine neue Karte hinzu!' };
                    }
                    this.flipped = false;
                    this.clearCanvas();
                },

                saveCards() {
                    localStorage.setItem('discere_cards', JSON.stringify(this.allCards));
                },
 
                shuffleCards() {
                    for (let i = this.cards.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [this.cards[i], this.cards[j]] = [this.cards[j], this.cards[i]];
                    }
                },
 
                nextCard() {
                    this.flipped = false;
                    this.clearCanvas();
                    setTimeout(() => {
                        if (this.cards.length === 0) return;
                        this.currentIndex++;
                        if (this.currentIndex >= this.cards.length) {
                            this.currentIndex = 0;
                            if (this.searchTerm.trim() === '' && this.cardOrder === 'random') {
                                this.shuffleCards();
                            }
                        }
                        this.currentCard = this.cards[this.currentIndex];
                    }, 300);
                },
 
                previousCard() {
                    this.flipped = false;
                    this.clearCanvas();
                    setTimeout(() => {
                        if (this.cards.length === 0) return;
                        this.currentIndex--;
                        if (this.currentIndex < 0) {
                            this.currentIndex = this.cards.length - 1;
                        }
                        this.currentCard = this.cards[this.currentIndex];
                    }, 300);
                },
 
                handleTouchStart(event) {
                    this.touchStartX = event.touches[0].clientX;
                },
 
                handleTouchEnd(event) {
                    const touchEndX = event.changedTouches[0].clientX;
                    const swipeDiff = this.touchStartX - touchEndX;
                    if (swipeDiff > 50) { this.nextCard(); }
                    else if (swipeDiff < -50) { this.previousCard(); }
                },
 
                updateSearchResults() {
                    const term = this.searchTerm.trim().toLowerCase();
                    if (term === '') {
                        this.searchResults = [];
                        return;
                    }
                    this.searchResults = this.allCards.filter(card =>
                        card.front.toLowerCase().includes(term) ||
                        card.back.toLowerCase().includes(term)
                    ).slice(0, 10);
                },
 
                selectCard(card) {
                    this.currentCard = card;
                    this.flipped = false;
                    this.clearCanvas();
                    this.searchTerm = '';
                    this.searchResults = [];
                    const foundIndex = this.cards.findIndex(c => c.id === card.id);
                    if (foundIndex !== -1) {
                        this.currentIndex = foundIndex;
                    }
                    this.cardListVisible = false;
                    this.selectedCards = [card.id];
                    this.lastSelectedCardId = card.id;
                },

                handleCardClick(card, event) {
                    const cardId = card.id;

                    if (event.shiftKey && this.lastSelectedCardId) {
                        event.preventDefault();
                        const lastIndex = this.sortedCards.findIndex(c => c.id === this.lastSelectedCardId);
                        const currentIndex = this.sortedCards.findIndex(c => c.id === cardId);
                        
                        const start = Math.min(lastIndex, currentIndex);
                        const end = Math.max(lastIndex, currentIndex);

                        const rangeIds = this.sortedCards.slice(start, end + 1).map(c => c.id);
                        
                        if (event.ctrlKey) {
                             rangeIds.forEach(id => {
                                if (!this.selectedCards.includes(id)) {
                                    this.selectedCards.push(id);
                                }
                            });
                        } else {
                            this.selectedCards = rangeIds;
                        }

                    } else if (event.ctrlKey) {
                        event.preventDefault();
                        if (this.selectedCards.includes(cardId)) {
                            this.selectedCards = this.selectedCards.filter(id => id !== cardId);
                        } else {
                            this.selectedCards.push(cardId);
                        }
                        this.lastSelectedCardId = cardId;
                    } else {
                        this.selectCard(card);
                    }
                },

                handleCardTouchStart(card, event) {
                   this.longPressTimer = setTimeout(() => {
                       event.preventDefault();
                       if (!this.selectedCards.includes(card.id)) {
                           this.selectedCards.push(card.id);
                       }
                       this.lastSelectedCardId = card.id;
                       this.longPressTimer = null;
                   }, 500);
               },

               handleCardTouchEnd(card, event) {
                   if (this.longPressTimer) {
                       clearTimeout(this.longPressTimer);
                       event.preventDefault();
                       
                       if (this.isMarkingMode) {
                           if (this.selectedCards.includes(card.id)) {
                               this.selectedCards = this.selectedCards.filter(id => id !== card.id);
                           } else {
                               this.selectedCards.push(card.id);
                           }
                           this.lastSelectedCardId = card.id;
                       } else {
                           this.selectCard(card);
                       }
                   }
               },

               handleCardTouchMove() {
                   if (this.longPressTimer) {
                       clearTimeout(this.longPressTimer);
                       this.longPressTimer = null;
                   }
               },

                resetSearch() {
                    this.searchTerm = '';
                    this.searchResults = [];
                    this.cards = [...this.allCards];
                    this.shuffleCards();
                    this.currentIndex = 0;
                    if (this.cards.length > 0) {
                       this.currentCard = this.cards[0];
                    }
                },
 
                exportCards() {
                    if (this.allCards.length === 0) {
                        alert('Keine Karten zum Exportieren vorhanden.');
                        return;
                    }
                    const filename = `discere-backup.json`;
                    const cardsToExport = this.allCards.map(({ id, ...rest }) => rest);
                    const dataStr = JSON.stringify(cardsToExport, null, 2);
                    const dataBlob = new Blob([dataStr], { type: 'application/json' });
                    const url = URL.createObjectURL(dataBlob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = filename;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    URL.revokeObjectURL(url);
                },
 
                importCards(event) {
                    const file = event.target.files[0];
                    if (!file) return;

                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            let content = e.target.result;
                            if (content.charCodeAt(0) === 0xFEFF) {
                                content = content.slice(1);
                            }
                            
                            const importedCards = JSON.parse(content);

                            if (!Array.isArray(importedCards) || !importedCards.every(c => c && typeof c.front === 'string' && typeof c.back === 'string')) {
                                alert('Ungültiges Dateiformat. Die Datei muss ein Array von Karten mit "front" und "back" Eigenschaften sein.');
                                return;
                            }

                            if (importedCards.length === 0) {
                                alert('Die importierte Datei enthält keine Karten.');
                                return;
                            }

                            this.cardsToImport = importedCards;

                            if (this.allCards.length > 0) {
                                this.showImportConfirmModal = true;
                            } else {
                                this.replaceImport();
                            }

                        } catch (error) {
                            console.error("Import-Fehler:", error);
                            alert('Fehler beim Verarbeiten der Datei. Stellen Sie sicher, dass es eine gültige JSON-Datei ist.');
                        }
                    };
                    reader.readAsText(file);
                    event.target.value = '';
                },

                mergeImport() {
                    const existingFronts = new Set(this.allCards.map(c => c.front.toLowerCase()));
                    let addedCount = 0;
                    this.cardsToImport.forEach(newCard => {
                        if (!existingFronts.has(newCard.front.toLowerCase())) {
                            this.allCards.push({ ...newCard, id: Date.now() + Math.random() });
                            addedCount++;
                        }
                    });
                    // A less intrusive notification could be implemented later
                    alert(`${addedCount} von ${this.cardsToImport.length} Karten wurden neu hinzugefügt. Duplikate wurden übersprungen.`);
                    this.finishImport();
                },

                replaceImport() {
                    this.allCards = this.cardsToImport.map(c => ({ ...c, id: Date.now() + Math.random() }));
                    alert(`${this.cardsToImport.length} Karten erfolgreich importiert und bestehende ersetzt.`);
                    this.finishImport();
                },

                cancelImport() {
                    this.showImportConfirmModal = false;
                    this.cardsToImport = [];
                },

                finishImport() {
                    this.saveCards();
                    this.loadCards();
                    this.cancelImport(); // Resets state
                },
 
                swapSides() {
                   this.sidesSwapped = !this.sidesSwapped;
                },

                setCardOrder(order) {
                   this.cardOrder = order;
                },

               setBackground(url) {
                   document.body.style.backgroundImage = `url('${url}')`;
                   localStorage.setItem('discere_background_image', url);
               },

               applyBgUrl() {
                   if (this.newBgUrl.trim()) {
                       this.setBackground(this.newBgUrl.trim());
                   }
               },

               handleBgUpload(event) {
                   const file = event.target.files[0];
                   if (!file) return;
                   const reader = new FileReader();
                   reader.onload = (e) => {
                       this.setBackground(e.target.result);
                   };
                   reader.readAsDataURL(file);
                   event.target.value = '';
               },

               removeBackground() {
                   document.body.style.backgroundImage = '';
                   localStorage.removeItem('discere_background_image');
                   // The accent color is now static CSS, so no JS update is needed.
               },

                deleteCard(cardToDelete) {
                    if (confirm(`Möchten Sie die Karte "${cardToDelete.front}" wirklich löschen?`)) {
                        this.allCards = this.allCards.filter(card => card.id !== cardToDelete.id);
                        this.selectedCards = this.selectedCards.filter(id => id !== cardToDelete.id);
                        this.saveCards();
                        this.loadCards();
                        alert('Karte gelöscht.');
                    }
                },

                deleteSelectedCards() {
                    if (this.selectedCards.length === 0) return;
                    if (confirm(`Möchten Sie die ${this.selectedCards.length} ausgewählten Karten wirklich löschen?`)) {
                        this.allCards = this.allCards.filter(card => !this.selectedCards.includes(card.id));
                        this.selectedCards = [];
                        this.lastSelectedCardId = null;
                        this.saveCards();
                        this.loadCards();
                        alert('Ausgewählte Karten gelöscht.');
                    }
                },

                deleteAllCards() {
                    if (confirm('Möchten Sie wirklich ALLE Karten unwiderruflich löschen? Diese Aktion kann nicht rückgängig gemacht werden.')) {
                        this.allCards = [];
                        this.selectedCards = [];
                        this.lastSelectedCardId = null;
                        this.saveCards();
                        this.loadCards();
                        this.showSettingsModal = false;
                        alert('Alle Karten wurden gelöscht.');
                    }
                },
 
                editCard(card) {
                    this.editingCard = card;
                    this.newCard = { ...card };
                    this.showAddCardModal = true;
                },
 
                closeModal() {
                    this.showAddCardModal = false;
                    this.editingCard = null;
                    this.newCard = { id: null, front: '', back: '' };
                },
 
                saveCard() {
                    if (!this.newCard.front.trim() || !this.newCard.back.trim()) {
                        alert('Vorder- und Rückseite dürfen nicht leer sein.');
                        return;
                    }

                    if (this.editingCard) {
                        const index = this.allCards.findIndex(c => c.id === this.editingCard.id);
                        if (index !== -1) {
                            this.allCards[index] = { ...this.newCard, id: this.editingCard.id };
                        }
                    } else {
                        const exists = this.allCards.some(c => c.front.toLowerCase() === this.newCard.front.toLowerCase());
                        if (exists && !confirm('Eine Karte mit dieser Vorderseite existiert bereits. Trotzdem hinzufügen?')) {
                            return;
                        }
                        this.allCards.push({ ...this.newCard, id: Date.now() });
                    }

                    this.saveCards();
                    this.loadCards();
                    this.closeModal();
                    alert(this.editingCard ? 'Karte aktualisiert!' : 'Karte hinzugefügt!');
                },

                adjustFontSize() {
                    this.$nextTick(() => {
                        const elements = [this.$refs.cardFrontText, this.$refs.cardBackText];
                        elements.forEach(el => {
                            if (!el) return;
                            
                            // Reset font size to the base size from the CSS class to recalculate
                            el.style.fontSize = '';
                            
                            // Use requestAnimationFrame to ensure the browser has rendered the element
                            requestAnimationFrame(() => {
                                let currentSize = parseFloat(window.getComputedStyle(el).fontSize);
                                // Check for overflow and reduce font size until it fits
                                while ((el.scrollHeight > el.clientHeight || el.scrollWidth > el.clientWidth) && currentSize > 14) {
                                    currentSize -= 1;
                                    el.style.fontSize = currentSize + 'px';
                                }
                            });
                        });
                    });
                },

 
               initCanvas() {
                   this.$nextTick(() => {
                       const canvas = this.$refs.drawingCanvas;
                       if(!canvas) return;
                       // Set canvas resolution to match its display size
                       canvas.width = canvas.offsetWidth;
                       canvas.height = canvas.offsetHeight;

                       this.canvasContext = canvas.getContext('2d');
                       this.canvasContext.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent-color');
                       this.canvasContext.lineWidth = 3;
                       this.canvasContext.lineCap = 'round';
                       this.canvasContext.lineJoin = 'round';

                       const getPos = (e) => {
                           const rect = canvas.getBoundingClientRect();
                           const scaleX = canvas.width / rect.width;
                           const scaleY = canvas.height / rect.height;
                           const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                           const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                           return {
                               x: (clientX - rect.left) * scaleX,
                               y: (clientY - rect.top) * scaleY
                           };
                       }

                       const startDrawing = (e) => {
                           e.preventDefault();
                           this.drawing = true;
                           const pos = getPos(e);
                           this.canvasContext.beginPath();
                           this.canvasContext.moveTo(pos.x, pos.y);
                       }

                       const draw = (e) => {
                           if (!this.drawing) return;
                           e.preventDefault();
                           const pos = getPos(e);
                           this.canvasContext.lineTo(pos.x, pos.y);
                           this.canvasContext.stroke();
                       }

                       const stopDrawing = () => {
                           this.drawing = false;
                       }

                       // Mouse events
                       canvas.addEventListener('mousedown', startDrawing);
                       canvas.addEventListener('mousemove', draw);
                       canvas.addEventListener('mouseup', stopDrawing);
                       canvas.addEventListener('mouseout', stopDrawing);

                       // Touch events
                       canvas.addEventListener('touchstart', startDrawing);
                       canvas.addEventListener('touchmove', draw);
                       canvas.addEventListener('touchend', stopDrawing);
                   });
               },

               clearCanvas() {
                   if (this.canvasContext) {
                       this.canvasContext.clearRect(0, 0, this.$refs.drawingCanvas.width, this.$refs.drawingCanvas.height);
                   }
               },

           }
       }
   </script>

</body>

<script>
    if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
            navigator.serviceWorker.register('sw.js').then(registration => {
                console.log('ServiceWorker registration successful with scope: ', registration.scope);
            }, err => {
                console.log('ServiceWorker registration failed: ', err);
            });
        });
    }
</script>

</html>