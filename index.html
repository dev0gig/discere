<!DOCTYPE html>
<html lang="de" class="dark">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Discere - Lernkarten</title>
<link rel="icon" type="image/svg+xml" href="discere.svg">
    <link rel="manifest" href="manifest.json">

    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js" defer></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/color-thief/2.3.2/color-thief.umd.js"></script>
 
     <link rel="preconnect" href="https://fonts.googleapis.com">
     <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet"
        href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />

    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Ubuntu', 'sans-serif'],
                    },
                    colors: {
                        'neutral-bg': '#121212',
                        'neutral-surface': '#1e1e1e',
                        'neutral-border': '#444444',
                        'neutral-primary': 'var(--accent-color)',
                        'neutral-secondary': '#03dac6',
                        'neutral-text': '#e0e0e0',
                        'neutral-dim': '#a0a0a0',
                    },
                    boxShadow: {
                        'primary': '0 0 12px rgba(0, 0, 0, 0.8)',
                    }
                }
            }
        }
    </script>

    <style>
       :root {
           --accent-color: #bb86fc;
       }
       body{overflow: hidden;}
       .card {
            transform-style: preserve-3d;
            transition: transform 0.6s;
        }

        .card-face {
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
        }

        .card-back {
            transform: rotateY(180deg);
        }

        .is-flipped {
            transform: rotateY(180deg);
        }

        .custom-scrollbar::-webkit-scrollbar {
            width: 8px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
            background: transparent;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background-color: #444444; /* neutral-border */
            border-radius: 4px;
            border: 2px solid #1e1e1e; /* neutral-surface */
        }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background-color: var(--accent-color);
        }
        .custom-scrollbar {
            scrollbar-width: thin;
            scrollbar-color: #444444 transparent; /* thumb track */
            -webkit-overflow-scrolling: touch;
        }
         .glass {
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 1rem;
        }
        .bottom-bar-glass {
             background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }
    </style>
</head>

<body class="font-sans text-neutral-text h-screen bg-cover bg-center bg-fixed" style="background-image: url('https://w.wallhaven.cc/full/gw/wallhaven-gwz8el.jpg');" x-data="flashcardTrainer()">

    <div class="container mx-auto p-4 h-full">

        <div class="flex flex-col md:flex-row md:gap-8 w-full h-full">

            <aside class="fixed inset-0 z-40 transform transition-transform duration-300 ease-in-out md:relative md:inset-auto md:w-1/3 md:transform-none md:z-auto glass" :class="{'translate-y-0': cardListVisible, 'translate-y-full': !cardListVisible}">
                <div class="p-4 h-full flex flex-col relative">
                    <div class="flex-shrink-0">
                        <div class="flex justify-between items-center mb-4">
                            <h2 class="font-bold text-2xl text-neutral-primary">Kartenliste</h2>
                            <button @click="cardListVisible = false" class="md:hidden p-1 rounded-md hover:bg-neutral-border">
                                <span class="material-symbols-outlined">close</span>
                            </button>
                        </div>
    
                        <div class="flex gap-2 mb-4">
                            <button @click="exportCards()" title="Backup erstellen" class="flex-1 flex items-center justify-center gap-2 px-3 py-2 rounded-md glass border-none hover:bg-neutral-primary hover:text-neutral-bg transition-colors text-sm">
                                <span class="material-symbols-outlined">save</span> Export
                            </button>
                            <button @click="$refs.importInput.click()" title="Backup einspielen" class="flex-1 flex items-center justify-center gap-2 px-3 py-2 rounded-md glass border-none hover:bg-neutral-primary hover:text-neutral-bg transition-colors text-sm">
                                <span class="material-symbols-outlined">folder_open</span> Import
                            </button>
                            <input type="file" x-ref="importInput" @change="importCards($event)" class="hidden" accept=".json">
                        </div>
     
                        <div class="flex gap-2 mb-4">
                            <button @click="showAddCardModal = true" class="flex-grow flex items-center justify-center gap-2 px-3 py-2 rounded-md bg-neutral-primary text-neutral-bg font-bold hover:shadow-primary transition-shadow">
                                <span class="material-symbols-outlined">add_circle</span> Neue Karte
                            </button>
                            <button x-show="selectedCards.length > 0" x-transition @click="deleteSelectedCards()" title="Ausgewählte löschen" class="flex-shrink-0 flex items-center justify-center p-2 rounded-md bg-neutral-secondary text-neutral-bg font-bold hover:shadow-lg transition-shadow">
                                <span class="material-symbols-outlined">delete</span>
                            </button>
                        </div>
                    </div>

                    <div @click.away="selectedCards = []; lastSelectedCardId = null" class="flex-grow min-h-0">
                        <div x-ref="cardListContainer" class="h-full overflow-y-auto pr-2 custom-scrollbar">
                            <template x-for="card in sortedCards" :key="card.id">
                                <div class="flex justify-between items-center group">
                                    <div @click="handleCardClick(card, $event)"
                                         @touchstart="handleCardTouchStart(card, $event)"
                                         @touchend="handleCardTouchEnd(card, $event)"
                                         @touchmove="handleCardTouchMove()"
                                         :class="selectedCards.includes(card.id) ? 'bg-neutral-primary text-neutral-bg' : 'hover:bg-neutral-primary/80 hover:text-neutral-bg'"
                                         class="flex-grow px-3 py-2 cursor-pointer rounded-md text-sm flex justify-between items-center transition-colors duration-200">
                                        <span x-text="card.front"></span>
                                        <span class="text-neutral-dim text-right" :class="{'text-neutral-bg': selectedCards.includes(card.id)}" x-text="card.back"></span>
                                    </div>
                                    <div class="flex items-center opacity-0 group-hover:opacity-100 transition-opacity">
                                        <button @click.stop="editCard(card)" class="p-1 text-neutral-dim hover:text-neutral-primary">
                                            <span class="material-symbols-outlined text-base">edit</span>
                                        </button>
                                        <button @click.stop="deleteCard(card)" class="p-1 text-neutral-dim hover:text-neutral-secondary">
                                            <span class="material-symbols-outlined text-base">delete</span>
                                        </button>
                                    </div>
                                </div>
                            </template>
                        </div>
                    </div>
                </div>
            </aside>

            <main class="w-full md:w-2/3 flex-shrink-0 flex flex-col p-2 h-full pb-20 md:pb-2">
                <div class="flex-shrink-0">
                    <p class="text-center text-neutral-dim mb-4 md:hidden">Klicke auf die Karte, um sie umzudrehen.</p>


                </div>

                <div class="flex-grow flex flex-col gap-4 min-h-0">
                    <!-- Drawing Canvas -->
                    <div class="flex-1 w-full min-h-0 relative">
                        <canvas x-ref="drawingCanvas" class="w-full h-full glass cursor-crosshair"></canvas>
                        <button @click="clearCanvas()" title="Feld leeren" class="absolute bottom-2 right-2 p-2 rounded-full text-red-500 hover:text-red-400 transition-colors flex items-center justify-center">
                            <span class="material-symbols-outlined">delete</span>
                        </button>
                    </div>

                    <!-- Card -->
                    <div @touchstart="handleTouchStart($event)" @touchend="handleTouchEnd($event)" style="perspective: 1000px;" class="w-full h-56 flex-shrink-0 min-h-0 md:flex-1 relative">
                        <!-- Nav Arrows -->
                        <button @click="previousCard()" class="absolute left-2 top-1/2 -translate-y-1/2 z-10 p-2 rounded-full text-neutral-dim hover:text-neutral-primary transition-colors">
                            <span class="material-symbols-outlined">chevron_left</span>
                        </button>
                        <button @click="nextCard()" class="absolute right-2 top-1/2 -translate-y-1/2 z-10 p-2 rounded-full text-neutral-dim hover:text-neutral-primary transition-colors">
                            <span class="material-symbols-outlined">chevron_right</span>
                        </button>

                        <div class="relative w-full h-full card" :class="{ 'is-flipped': flipped }">
                            <div @click="flipped = !flipped"
                                class="absolute w-full h-full card-face glass flex items-center justify-center cursor-pointer shadow-primary p-4 overflow-hidden">
                                <button @click.stop="swapSides()" title="Seiten tauschen" class="absolute top-2 right-2 p-2 rounded-full text-neutral-dim hover:text-neutral-primary transition-colors z-10">
                                    <span class="material-symbols-outlined">sync</span>
                                </button>
                                <p class="text-3xl md:text-4xl font-bold text-neutral-text text-center"
                                    x-text="currentCard.front" x-ref="cardFrontText"></p>
                            </div>
                            <div @click="flipped = !flipped"
                                class="absolute w-full h-full card-face card-back glass flex flex-col items-center justify-center cursor-pointer shadow-primary p-4 overflow-hidden">
                                <button @click.stop="swapSides()" title="Seiten tauschen" class="absolute top-2 right-2 p-2 rounded-full text-neutral-dim hover:text-neutral-primary transition-colors z-10">
                                    <span class="material-symbols-outlined">sync</span>
                                </button>
                                <p class="text-3xl md:text-4xl font-bold text-neutral-primary text-center"
                                    x-text="currentCard.back" x-ref="cardBackText"></p>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="flex-shrink-0 mt-4">
                    <div class="mb-4 w-full relative">
                        <input type="text" x-model="searchTerm" @input.debounce.300ms="updateSearchResults()"
                            placeholder="Karte suchen..."
                            class="w-full px-4 py-2 pr-10 glass border-none rounded-md focus:outline-none focus:ring-2 focus:ring-neutral-primary text-neutral-text placeholder-neutral-dim">
                        <button @click="resetSearch()" x-show="searchTerm.trim() !== ''" x-transition class="absolute top-1/2 right-3 transform -translate-y-1/2 text-neutral-dim hover:text-neutral-primary z-10 cursor-pointer">
                            <span class="material-symbols-outlined">close</span>
                        </button>

                        <div x-show="searchResults.length > 0" x-transition
                            class="absolute z-10 w-full bottom-full mb-1 glass border-none rounded-md max-h-60 overflow-y-auto shadow-lg">
                            <template x-for="card in searchResults" :key="card.id">
                                <div @click="selectCard(card)"
                                    class="px-4 py-2 cursor-pointer hover:bg-neutral-primary/80 hover:text-neutral-bg flex justify-between items-center">
                                    <span x-text="card.front"></span>
                                    <span class="text-neutral-dim text-right" x-text="card.back"></span>
                                </div>
                            </template>
                        </div>
                    </div>
                </div>
            </main>


           <div x-show="showAddCardModal" x-transition:enter="transition ease-out duration-300" x-transition:enter-start="opacity-0" x-transition:enter-end="opacity-100" x-transition:leave="transition ease-in duration-200" x-transition:leave-start="opacity-100" x-transition:leave-end="opacity-0" class="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4" style="display: none;">
               <div @click.away="closeModal()" class="glass shadow-primary p-6 w-full max-w-md">
                   <h3 class="font-bold text-2xl text-neutral-primary mb-4" x-text="editingCard ? 'Karte bearbeiten' : 'Neue Karte hinzufügen'"></h3>
                   <form @submit.prevent="saveCard()">
                       <div class="space-y-4">
                           <div>
                               <label for="newFront" class="block text-neutral-dim mb-1">Vorderseite</label>
                               <input type="text" id="newFront" x-model="newCard.front" required class="w-full px-3 py-2 glass border-none rounded-md focus:outline-none focus:ring-2 focus:ring-neutral-primary text-neutral-text placeholder-neutral-dim">
                           </div>
                           <div>
                               <label for="newBack" class="block text-neutral-dim mb-1">Rückseite</label>
                               <input type="text" id="newBack" x-model="newCard.back" required class="w-full px-3 py-2 glass border-none rounded-md focus:outline-none focus:ring-2 focus:ring-neutral-primary text-neutral-text placeholder-neutral-dim">
                           </div>
                       </div>
                       <div class="flex justify-end gap-4 mt-6">
                           <button type="button" @click="closeModal()" class="px-4 py-2 rounded-md text-neutral-dim hover:text-neutral-primary">Abbrechen</button>
                           <button type="submit" class="px-4 py-2 rounded-md bg-neutral-primary text-neutral-bg font-bold hover:shadow-primary">Speichern</button>
                       </div>
                   </form>
               </div>
           </div>

        </div>
    
        <!-- Bottom Bar -->
        <div class="md:hidden fixed bottom-0 left-0 right-0 h-16 flex items-center justify-between px-4 z-30 bottom-bar-glass">
            <h1 class="font-bold text-2xl text-neutral-primary">Discere</h1>
            <button @click="cardListVisible = !cardListVisible" class="p-2">
                <span class="material-symbols-outlined text-3xl">menu</span>
            </button>
        </div>
    </div>
 
    <script>
        function flashcardTrainer() {
            return {
                // Data State
                // Data State
                allCards: [], // The full, sorted list of all cards
                
                // View/UI State
                cards: [], // The shuffled, currently active card set for training
                currentIndex: 0,
                currentCard: { id: 0, front: 'Lade...', back: '...' },
                flipped: false,
                searchTerm: '',
                searchResults: [],
                cardListVisible: false,
                showAddCardModal: false,
                newCard: { id: null, front: '', back: '' },
                editingCard: null,
                selectedCards: [],
                lastSelectedCardId: null,
 
                // Touch / Selection State
                longPressTimer: null,
                isMarkingMode: false,

                // Canvas State
                drawing: false,
                canvasContext: null,
                touchStartX: 0,

                get sortedCards() {
                    return [...this.allCards].sort((a, b) => a.front.localeCompare(b.front));
                },

                init() {
                    this.loadCards();
                    this.initCanvas();
                    this.updateAccentColor();

                    this.$watch('currentCard', () => this.adjustFontSize());
                    this.$watch('flipped', () => this.adjustFontSize());
                    this.$watch('selectedCards.length', (length) => {
                       this.isMarkingMode = length > 0;
                    });
                    let resizeTimeout;
                    window.addEventListener('resize', () => {
                        clearTimeout(resizeTimeout);
                        resizeTimeout = setTimeout(() => {
                            this.adjustFontSize();
                            
                            this.$nextTick(() => {
                                const canvas = this.$refs.drawingCanvas;
                                if (!canvas || !this.canvasContext) return;
                                canvas.width = canvas.offsetWidth;
                                canvas.height = canvas.offsetHeight;
                                // Re-apply styles as they can be reset
                                this.canvasContext.strokeStyle = '#bb86fc';
                                this.canvasContext.lineWidth = 3;
                                this.canvasContext.lineCap = 'round';
                                this.canvasContext.lineJoin = 'round';
                            });
                        }, 150);
                    });
                },

                loadCards() {
                    const savedCards = localStorage.getItem('discere_cards');
                    if (savedCards) {
                        try {
                            const parsedCards = JSON.parse(savedCards);
                            if (Array.isArray(parsedCards)) {
                                this.allCards = parsedCards.map(c => ({...c, id: c.id || Date.now() + Math.random()}));
                            }
                        } catch (e) {
                            console.error("Fehler beim Laden der Karten.", e);
                            this.allCards = [];
                        }
                    } else {
                         this.allCards = [];
                    }
                    
                    this.cards = [...this.allCards];
                    this.shuffleCards();
                    this.currentIndex = 0;
                    if (this.cards.length > 0) {
                        this.currentCard = this.cards[0];
                    } else {
                        this.currentCard = { id: 0, front: 'Keine Karten', back: 'Füge eine neue Karte hinzu!' };
                    }
                    this.flipped = false;
                    this.clearCanvas();
                },

                saveCards() {
                    localStorage.setItem('discere_cards', JSON.stringify(this.allCards));
                },
 
                shuffleCards() {
                    for (let i = this.cards.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [this.cards[i], this.cards[j]] = [this.cards[j], this.cards[i]];
                    }
                },
 
                nextCard() {
                    this.flipped = false;
                    this.clearCanvas();
                    setTimeout(() => {
                        if (this.cards.length === 0) return;
                        this.currentIndex++;
                        if (this.currentIndex >= this.cards.length) {
                            this.currentIndex = 0;
                            if (this.searchTerm.trim() === '') {
                                this.shuffleCards();
                            }
                        }
                        this.currentCard = this.cards[this.currentIndex];
                    }, 300);
                },
 
                previousCard() {
                    this.flipped = false;
                    this.clearCanvas();
                    setTimeout(() => {
                        if (this.cards.length === 0) return;
                        this.currentIndex--;
                        if (this.currentIndex < 0) {
                            this.currentIndex = this.cards.length - 1;
                        }
                        this.currentCard = this.cards[this.currentIndex];
                    }, 300);
                },
 
                handleTouchStart(event) {
                    this.touchStartX = event.touches[0].clientX;
                },
 
                handleTouchEnd(event) {
                    const touchEndX = event.changedTouches[0].clientX;
                    const swipeDiff = this.touchStartX - touchEndX;
                    if (swipeDiff > 50) { this.nextCard(); }
                    else if (swipeDiff < -50) { this.previousCard(); }
                },
 
                updateSearchResults() {
                    const term = this.searchTerm.trim().toLowerCase();
                    if (term === '') {
                        this.searchResults = [];
                        return;
                    }
                    this.searchResults = this.allCards.filter(card =>
                        card.front.toLowerCase().includes(term) ||
                        card.back.toLowerCase().includes(term)
                    ).slice(0, 10);
                },
 
                selectCard(card) {
                    this.currentCard = card;
                    this.flipped = false;
                    this.clearCanvas();
                    this.searchTerm = '';
                    this.searchResults = [];
                    const foundIndex = this.cards.findIndex(c => c.id === card.id);
                    if (foundIndex !== -1) {
                        this.currentIndex = foundIndex;
                    }
                    this.cardListVisible = false;
                    this.selectedCards = [card.id];
                    this.lastSelectedCardId = card.id;
                },

                handleCardClick(card, event) {
                    const cardId = card.id;

                    if (event.shiftKey && this.lastSelectedCardId) {
                        event.preventDefault();
                        const lastIndex = this.sortedCards.findIndex(c => c.id === this.lastSelectedCardId);
                        const currentIndex = this.sortedCards.findIndex(c => c.id === cardId);
                        
                        const start = Math.min(lastIndex, currentIndex);
                        const end = Math.max(lastIndex, currentIndex);

                        const rangeIds = this.sortedCards.slice(start, end + 1).map(c => c.id);
                        
                        if (event.ctrlKey) {
                             rangeIds.forEach(id => {
                                if (!this.selectedCards.includes(id)) {
                                    this.selectedCards.push(id);
                                }
                            });
                        } else {
                            this.selectedCards = rangeIds;
                        }

                    } else if (event.ctrlKey) {
                        event.preventDefault();
                        if (this.selectedCards.includes(cardId)) {
                            this.selectedCards = this.selectedCards.filter(id => id !== cardId);
                        } else {
                            this.selectedCards.push(cardId);
                        }
                        this.lastSelectedCardId = cardId;
                    } else {
                        this.selectCard(card);
                    }
                },

                handleCardTouchStart(card, event) {
                   this.longPressTimer = setTimeout(() => {
                       event.preventDefault();
                       if (!this.selectedCards.includes(card.id)) {
                           this.selectedCards.push(card.id);
                       }
                       this.lastSelectedCardId = card.id;
                       this.longPressTimer = null;
                   }, 500);
               },

               handleCardTouchEnd(card, event) {
                   if (this.longPressTimer) {
                       clearTimeout(this.longPressTimer);
                       event.preventDefault();
                       
                       if (this.isMarkingMode) {
                           if (this.selectedCards.includes(card.id)) {
                               this.selectedCards = this.selectedCards.filter(id => id !== card.id);
                           } else {
                               this.selectedCards.push(card.id);
                           }
                           this.lastSelectedCardId = card.id;
                       } else {
                           this.selectCard(card);
                       }
                   }
               },

               handleCardTouchMove() {
                   if (this.longPressTimer) {
                       clearTimeout(this.longPressTimer);
                       this.longPressTimer = null;
                   }
               },

                resetSearch() {
                    this.searchTerm = '';
                    this.searchResults = [];
                    this.cards = [...this.allCards];
                    this.shuffleCards();
                    this.currentIndex = 0;
                    if (this.cards.length > 0) {
                       this.currentCard = this.cards[0];
                    }
                },
 
                exportCards() {
                    if (this.allCards.length === 0) {
                        alert('Keine Karten zum Exportieren vorhanden.');
                        return;
                    }
                    const filename = `discere-backup.json`;
                    const cardsToExport = this.allCards.map(({ id, ...rest }) => rest);
                    const dataStr = JSON.stringify(cardsToExport, null, 2);
                    const dataBlob = new Blob([dataStr], { type: 'application/json' });
                    const url = URL.createObjectURL(dataBlob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = filename;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    URL.revokeObjectURL(url);
                },
 
                importCards(event) {
                    const file = event.target.files[0];
                    if (!file) return;
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            let content = e.target.result;
                            if (content.charCodeAt(0) === 0xFEFF) content = content.slice(1);
                            const importedCards = JSON.parse(content);
                            if (Array.isArray(importedCards) && (importedCards.length === 0 || (importedCards[0].front && importedCards[0].back))) {
                                const newCards = importedCards.map(c => ({...c, id: Date.now() + Math.random()}));
                                this.allCards = newCards;
                                this.saveCards();
                                this.loadCards();
                                alert(`${importedCards.length} Karten erfolgreich importiert!`);
                            } else {
                                alert('Ungültiges Dateiformat.');
                            }
                        } catch (error) {
                            console.error("Import-Fehler:", error);
                            alert('Fehler beim Verarbeiten der Datei.');
                        }
                    };
                    reader.readAsText(file);
                    event.target.value = '';
                },
 
                swapSides() {
                    this.allCards = this.allCards.map(card => ({ ...card, front: card.back, back: card.front }));
                    this.saveCards();
                    this.loadCards();
                },

                deleteCard(cardToDelete) {
                    if (confirm(`Möchten Sie die Karte "${cardToDelete.front}" wirklich löschen?`)) {
                        this.allCards = this.allCards.filter(card => card.id !== cardToDelete.id);
                        this.selectedCards = this.selectedCards.filter(id => id !== cardToDelete.id);
                        this.saveCards();
                        this.loadCards();
                        alert('Karte gelöscht.');
                    }
                },

                deleteSelectedCards() {
                    if (this.selectedCards.length === 0) return;
                    if (confirm(`Möchten Sie die ${this.selectedCards.length} ausgewählten Karten wirklich löschen?`)) {
                        this.allCards = this.allCards.filter(card => !this.selectedCards.includes(card.id));
                        this.selectedCards = [];
                        this.lastSelectedCardId = null;
                        this.saveCards();
                        this.loadCards();
                        alert('Ausgewählte Karten gelöscht.');
                    }
                },
 
                editCard(card) {
                    this.editingCard = card;
                    this.newCard = { ...card };
                    this.showAddCardModal = true;
                },
 
                closeModal() {
                    this.showAddCardModal = false;
                    this.editingCard = null;
                    this.newCard = { id: null, front: '', back: '' };
                },
 
                saveCard() {
                    if (!this.newCard.front.trim() || !this.newCard.back.trim()) {
                        alert('Vorder- und Rückseite dürfen nicht leer sein.');
                        return;
                    }

                    if (this.editingCard) {
                        const index = this.allCards.findIndex(c => c.id === this.editingCard.id);
                        if (index !== -1) {
                            this.allCards[index] = { ...this.newCard, id: this.editingCard.id };
                        }
                    } else {
                        const exists = this.allCards.some(c => c.front.toLowerCase() === this.newCard.front.toLowerCase());
                        if (exists && !confirm('Eine Karte mit dieser Vorderseite existiert bereits. Trotzdem hinzufügen?')) {
                            return;
                        }
                        this.allCards.push({ ...this.newCard, id: Date.now() });
                    }

                    this.saveCards();
                    this.loadCards();
                    this.closeModal();
                    alert(this.editingCard ? 'Karte aktualisiert!' : 'Karte hinzugefügt!');
                },

                adjustFontSize() {
                    this.$nextTick(() => {
                        const elements = [this.$refs.cardFrontText, this.$refs.cardBackText];
                        elements.forEach(el => {
                            if (!el) return;
                            
                            // Reset font size to the base size from the CSS class to recalculate
                            el.style.fontSize = '';
                            
                            // Use requestAnimationFrame to ensure the browser has rendered the element
                            requestAnimationFrame(() => {
                                let currentSize = parseFloat(window.getComputedStyle(el).fontSize);
                                // Check for overflow and reduce font size until it fits
                                while ((el.scrollHeight > el.clientHeight || el.scrollWidth > el.clientWidth) && currentSize > 14) {
                                    currentSize -= 1;
                                    el.style.fontSize = currentSize + 'px';
                                }
                            });
                        });
                    });
                },

 
               initCanvas() {
                   this.$nextTick(() => {
                       const canvas = this.$refs.drawingCanvas;
                       if(!canvas) return;
                       // Set canvas resolution to match its display size
                       canvas.width = canvas.offsetWidth;
                       canvas.height = canvas.offsetHeight;

                       this.canvasContext = canvas.getContext('2d');
                       this.canvasContext.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent-color');
                       this.canvasContext.lineWidth = 3;
                       this.canvasContext.lineCap = 'round';
                       this.canvasContext.lineJoin = 'round';

                       const getPos = (e) => {
                           const rect = canvas.getBoundingClientRect();
                           const scaleX = canvas.width / rect.width;
                           const scaleY = canvas.height / rect.height;
                           const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                           const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                           return {
                               x: (clientX - rect.left) * scaleX,
                               y: (clientY - rect.top) * scaleY
                           };
                       }

                       const startDrawing = (e) => {
                           e.preventDefault();
                           this.drawing = true;
                           const pos = getPos(e);
                           this.canvasContext.beginPath();
                           this.canvasContext.moveTo(pos.x, pos.y);
                       }

                       const draw = (e) => {
                           if (!this.drawing) return;
                           e.preventDefault();
                           const pos = getPos(e);
                           this.canvasContext.lineTo(pos.x, pos.y);
                           this.canvasContext.stroke();
                       }

                       const stopDrawing = () => {
                           this.drawing = false;
                       }

                       // Mouse events
                       canvas.addEventListener('mousedown', startDrawing);
                       canvas.addEventListener('mousemove', draw);
                       canvas.addEventListener('mouseup', stopDrawing);
                       canvas.addEventListener('mouseout', stopDrawing);

                       // Touch events
                       canvas.addEventListener('touchstart', startDrawing);
                       canvas.addEventListener('touchmove', draw);
                       canvas.addEventListener('touchend', stopDrawing);
                   });
               },

               clearCanvas() {
                   if (this.canvasContext) {
                       this.canvasContext.clearRect(0, 0, this.$refs.drawingCanvas.width, this.$refs.drawingCanvas.height);
                   }
               },

              updateAccentColor() {
                  const colorThief = new ColorThief();
                  const img = new Image();
                  const bodyStyles = window.getComputedStyle(document.body);
                  const imageUrl = bodyStyles.backgroundImage.slice(4, -1).replace(/"/g, "");

                  if (!imageUrl) return;

                  img.crossOrigin = 'Anonymous';
                  img.src = imageUrl;

                  img.onload = () => {
                      const dominantColor = colorThief.getColor(img);
                      const accentColor = this.generateAccentColor(dominantColor);
                      
                      document.documentElement.style.setProperty('--accent-color', accentColor);
                      
                      if (this.canvasContext) {
                          this.canvasContext.strokeStyle = accentColor;
                      }
                  };
                  img.onerror = (e) => {
                      console.error("Fehler beim Laden des Hintergrundbildes für die Farbanalyse.", e);
                  }
              },

              generateAccentColor(rgb) {
                  let [r, g, b] = rgb;
                  // Convert RGB to HSL
                  r /= 255; g /= 255; b /= 255;
                  const max = Math.max(r, g, b), min = Math.min(r, g, b);
                  let h, s, l = (max + min) / 2;

                  if (max === min) {
                      h = s = 0; // achromatic
                  } else {
                      const d = max - min;
                      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                      switch (max) {
                          case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                          case g: h = (b - r) / d + 2; break;
                          case b: h = (r - g) / d + 4; break;
                      }
                      h /= 6;
                  }

                  // Adjust HSL to create a vibrant accent color
                  s = Math.max(0.6, s * 1.2); // Increase saturation, but not less than 0.6
                  l = Math.max(0.65, l * 1.1); // Increase lightness, but not less than 0.65
                  s = Math.min(1, s);
                  l = Math.min(0.8, l);

                  // Convert HSL back to RGB
                  let r_out, g_out, b_out;
                  if (s === 0) {
                      r_out = g_out = b_out = l;
                  } else {
                      const hue2rgb = (p, q, t) => {
                          if (t < 0) t += 1;
                          if (t > 1) t -= 1;
                          if (t < 1/6) return p + (q - p) * 6 * t;
                          if (t < 1/2) return q;
                          if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                          return p;
                      }
                      const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                      const p = 2 * l - q;
                      r_out = hue2rgb(p, q, h + 1/3);
                      g_out = hue2rgb(p, q, h);
                      b_out = hue2rgb(p, q, h - 1/3);
                  }
                  
                  const toHex = x => {
                      const hex = Math.round(x * 255).toString(16);
                      return hex.length === 1 ? '0' + hex : hex;
                  };
                  
                  return `#${toHex(r_out)}${toHex(g_out)}${toHex(b_out)}`;
              }
           }
       }
   </script>

</body>

<script>
    if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
            navigator.serviceWorker.register('sw.js').then(registration => {
                console.log('ServiceWorker registration successful with scope: ', registration.scope);
            }, err => {
                console.log('ServiceWorker registration failed: ', err);
            });
        });
    }
</script>

</html>